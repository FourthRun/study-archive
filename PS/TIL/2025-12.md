# [2025-12-24] | BOJ / 2744 - 대소문자 바꾸기 | B5
## 1. Approach
문자열을 순회하며 ASCII 값 차이를 이용해 대소문자를 변환하고자 하였다. 

## 2. Solution
```cpp
for(char c : s) {
    if(c >= 'A' && c <= 'Z') cout << (char)(c + 32);
    else cout << (char)(c - 32);
}
// #include <cctype>
// == (char)tolower(c), (char)toupper(c)
```

## 3. Lesson
- 내가 간과한 사실은 대소문자의 ASCII 값 차이가 26이 아니라 32였다는 것이다. 대문자가 65\~90의 값을 가지고 있는 한편, 소문자는 97\~122의 값을 가지고 있었고 그 사이에는 [, \\, ], ^, _, `에 해당하는 값들이 존재했다.
- `(char)c + 32`와 `(char)(c + 32)`는 다른 값을 출력한다. 첫 번째 식은 (char)가 c값 만 형변환 하는 반면, 두번째 식은 c + 32의 결괏값을 문자로 형변환한다.
- ASCII 값의 차를 이용하지 않고 `<ctype>` 라이브러리의 변환 함수 `tolower()`, `toupper()`와 판별 함수 `islower()`, `isupper()`를 사용할 수도 있다. 참고로 판별 함수는 bool값이 아니라 int값의 1(참) 또는 0(거짓)을 반환한다.


# [2025-12-24] | BOJ / 2745 - 진법 변환 | B2
## 1. Approach
입력 받은 문자열을 `reverse()`로 뒤집은 뒤, 일의 자리부터 순회하며 각 자릿수의 계수 `digit`에 자릿수 가중치 `power`를 곱하여 총합 `sum`에 누적하였다.
```cpp
long long sum = 0;
int power = 1;

reverse(s.begin(), s.end());

for(char c : s) {
    if(c >= '0' && c <= '9') digit = c - '0';
    else digit = c - 'A' + 10;

    sum += digit * power;
    power *= base;
}
```

## 2. Solution
```cpp
long long sum = 0;

for(char c : s) {
    if(c >= '0' && c <= '9') digit = c - '0';
    else digit = c - 'A' + 10;

    sum = sum * base + digit;
}
```

## 3. Lesson
- 총합 `sum`에 진법 `base`를 곱하는 것은 전체 자릿수를 한 칸씩 왼쪽으로 미는 것과 같다. 여기에 새로운 자릿수의 계수 `digit`을 더하면 별도의 거듭제곱 연산 없이도 진법 변환이 가능하다. 이를 호너의 법칙(Horner's method)라고 한다.
- `<cmath>` 라이브러리의 `pow()`는 정수값이 아닌 실수값으로 계산되기에 부동소수점 근사값 문제가 야기될 수 있어 적절한 방법이 아니다.


# [2025-12-26] | BOJ / 5073 - 삼각형과 세 변 | B3
## 1. Approach
while문과 `cin`을 이용하여 초기화된 벡터 `v`에 직접 입력을 받으려고 하였다.

## 2. Solution
```cpp
vector<int> v(3);

while(cin >> v[0] >> v[1]>> v[2]) {
    sort(v.begin(), v.end());

    if(v[0] == 0 && v[1] == 0 && v[2] == 0) break;
    else if(v[0] + v[1] <= v[2]) cout << "Invalid";
    else if(v[0] == v[1] && v[1] == v[2]) cout << "Equilateral";
    else if(v[0] == v[1] || v[1] == v[2] || v[2] == v[0]) cout << "Isosceles";
    else cout << "Scalene";

    cout << "\n";
}
```

## 3. Lesson
- `vector<int> v;`과 같은 초기화된 벡터는 크기가 정해져있지 않기 때문에 `v[0]`과 같이 직접 칸에 접근하는 것은 불가능하다. 이를 해결하기 위해 `vector<int> v(3);`처럼 벡터의 크기를 미리 정해둘 수도 있고, 임시 변수를 선언하여 `vector<int> v = {a, b, c};`처럼 사용할 수도 있다.